/*
 *  Timed execution routine. Starts a timer and executes a sequence
 *  of commands when expired.
 *
 *  Added by IW0CNB - Feb 1992
 *  'at mm' format added by WG7J - 920805
 *
 *      Added by WA7TAS Oct 1992:
 *
 *         'at k' command
 *
 *         Repeating AT command
 *           - bug fix June 2, 1993
 *           - merged changes into Johan's new code June 14, 1993
 *
 * May 2021, Maiko (VE4KLM) - stability mods !
 *
 */
#include <time.h>
#ifdef MSDOS
#include <dos.h>
#endif
#include "global.h"
#ifdef ATCMD
#include "timer.h"
#include "proc.h"
#include "cmdparse.h"
#include "socket.h"
#include "commands.h"
#include "unixtm.h"
  
void atcmd __ARGS((char *command));
void atproc __ARGS((int i,void *p1,void *p2));
char *requote __ARGS((char *s, char *prepend, char *append));
  
/* List of events; We keep note of all timer processes generated by the
 * at command.
 */
struct at_list {
    struct at_list *next;   /* Linked-list pointer */
    struct timer *at_timer;
/*
 * 20May2021, Maiko (VE4KLM), I am trying really hard to understand why the
 * length of recur is only 10 bytes, I am now wondering if this was a typo,
 * and the original author had meant to put in 100 bytes instead ?
 * 
 * Ron (VE3CGR) has been experiencing lockups, and after getting him to do
 * a bunch of CTRL-C and 'cont' at the GDB prompt, it looks like the id is
 * possibly corrupted (it's looping on that continue further down). The only
 * way this is possible that I can see of, is if structure member 'recur' is
 * overflowed with a string bigger then it can handle, messing up the 'id'.
 *
 * I think I will use a pointer here and just alloc the memory as needed.
 *
    char   recur[10];
 */
    char *recur;	/* used in recursive 'at' commands*/

    unsigned int id;    /* numerical 'id' of this 'at' */
};
  
#define NULLATLIST  (struct at_list *)0
  
static struct at_list *Head_loe = NULLATLIST;   /* Head of List Of Events */
static int id=1;        /* next 'at' assigned gets this number */
static char AtErrmsg[] = "Usage:\nat yymmddhhmm <cmd>\nat dhhmm <cmd>\nat hhmm <cmd>\nat mm <cmd>\nat now+hhmm <cmd>\nat k <id num> <id num> ...\n";

/* 01Dec2004, Maiko, New function replaces 'error:' GOTO and labels */
static int do_error (struct date *exp_date, struct time *exp_time, char *cp)
{
	tprintf("%s", AtErrmsg); /* 05Jul2016, Maiko, Compiler, remove DFAR */
	free(exp_date);
	free(exp_time);
	free(cp);
	return 1;
}

int
doat(argc,argv,p)
int argc;
char *argv[];
void *p;
{
    struct date *exp_date;
    struct time *exp_time;
    struct timer *t;
  
    char *cp,*dp;
    unsigned int tid;
    int i, notf, argvlen;
    time_t nowtime;
    unsigned long time1;
    struct tm tm;
    extern struct timer *Timers;
    struct at_list *loe,*pp;    /* List of events */
  
    if(argc < 2){       /* Print list of pending at commands */
        j2tputs("List of events:\n");
  
        for(t = Timers;t != NULLTIMER;t = t->next){
            if(t->func == (void (*)__ARGS((void*)))atcmd){
                loe=Head_loe;
                while(loe!=NULLATLIST) {
                    if(loe->at_timer == t) break;
                    loe=loe->next;
                }
                time(&nowtime);
                nowtime = (time_t)((uint32)read_timer(t) / 1000L + (unsigned long)nowtime);
                cp = ctime(&nowtime);
                dp = strrchr(t->arg,'|');
                *dp = 0;
                tprintf("At: %.24s - ID: %5u - Command: %s\n",cp,loe->id, (char*)t->arg);
                *dp = '|';
            }
        }
        return 0;
    }
  
    if(argc < 3){
        j2tputs(AtErrmsg);
        return 1;
    }
  
    if(argv[1][0]=='k') {
        i=2;
        while(i<argc) {
            tid=atoi(argv[i]);
            if(strlen(argv[i])>5 || tid==0 || atol(argv[i])>65535L) {
                tprintf("Invalid ID #.\n");
                return 1;
            }
            loe=Head_loe;
            notf=1;
            pp = NULL;
            while(loe!=NULLATLIST) {
                if(loe->id==tid) {
                    stop_timer(loe->at_timer);
                    free(loe->at_timer->arg);
                    free(loe->at_timer);
                    if(loe == Head_loe) {
                        Head_loe=loe->next;
                    }
                    else {
                        pp->next=loe->next;
                    }
		    if (loe->recur)			/* 20May2021, Maiko */
			free (loe->recur);
                    free(loe);
                    tprintf("at id: %u--Killed.\n",tid);
                    notf=0;
                    break;
                }
                pp=loe;
                loe=loe->next;
            }
            if(notf) tprintf("  ID %u not found.\n",tid);
            i++;
        }
        return 0;
    }
    exp_date = (struct date *)mallocw(sizeof(struct date));
    exp_time = (struct time *)mallocw(sizeof(struct time));
  
    cp=mallocw(5);
  
	argvlen = strlen (argv[1]);
    switch (argvlen)
	{
        case 10: /* Full date and time given */
            cp[0]=argv[1][0];
            cp[1]=argv[1][1];
            cp[2]='\0';
  
            exp_date->da_year = 1900 + atoi(cp);
            if(exp_date->da_year < 1970) exp_date->da_year += 100; /* 21-st century */
  
            cp[0]=argv[1][2];
            cp[1]=argv[1][3];
            cp[2]='\0';
  
            exp_date->da_mon = (char)atoi(cp);
            if(exp_date->da_mon > 12)
				return (do_error (exp_date, exp_time, cp));
  
            cp[0]=argv[1][4];
            cp[1]=argv[1][5];
            cp[2]='\0';
  
            exp_date->da_day = (char)atoi(cp);
            if(exp_date->da_day > 31)
				return (do_error (exp_date, exp_time, cp));
  
            cp[0]=argv[1][6];
            cp[1]=argv[1][7];
            cp[2]='\0';
  
            exp_time->ti_hour = (char)atoi(cp);
            if(exp_time->ti_hour > 23)
				return (do_error (exp_date, exp_time, cp));
  
            cp[0]=argv[1][8];
            cp[1]=argv[1][9];
            cp[2]='\0';
  
            exp_time->ti_min = (char)atoi(cp);
            if(exp_time->ti_min > 59)
				return (do_error (exp_date, exp_time, cp));
  
            exp_time->ti_sec = 5;     /* n5knx: assure we're never early */
            exp_time->ti_hund = 0;
  
            time(&nowtime);
            time1 = (unsigned long)dostounix(exp_date,exp_time);
            if(time1 < (unsigned long)nowtime)
				return (do_error (exp_date, exp_time, cp));
  
            break;
  
        case 5:  /* DOW+time given */

            i = (*argv[1]++ - '0') % 7; /* dow: 0=Sun,1=Mon,...,6=Sat,7=Sun */

        	/* flow through (replaces goto) uses new argvlen variable */

        case 4:  /* Only time given, so apply current date */

			if (argvlen == 4)
            	i=-1;  /* we're sharing code with dow+hhmm case */

            j2getdate(exp_date);
            cp[0]=argv[1][0];
            cp[1]=argv[1][1];
            cp[2]='\0';
  
            exp_time->ti_hour = (char)atoi(cp);
            if(exp_time->ti_hour > 23)
				return (do_error (exp_date, exp_time, cp));
  
            cp[0]=argv[1][2];
            cp[1]=argv[1][3];
            cp[2]='\0';
  
            exp_time->ti_min = (char)atoi(cp);
            if(exp_time->ti_min > 59)
				return (do_error (exp_date, exp_time, cp));
  
            exp_time->ti_sec = 5;     /* n5knx: assure we're never early */
            exp_time->ti_hund = 0;
  
            time(&nowtime);
            time1 = (unsigned long)dostounix(exp_date,exp_time);
            if (i!=-1) {  /* get weekday corresponding to time1 */
                memcpy((void *)&tm, (void *)localtime((time_t *)&time1), sizeof(struct tm));
                argv[1]--;  /* backup to start of whhmm, so resched works later on */
            }

            while(time1 <= (unsigned long)nowtime || (i!=-1 && i!=tm.tm_wday))
			{ /* Requested time has passed */
                time1 += 86400L;        /* So book him 24hrs later */
			/*
			 * 15Apr2016, Maiko (VE4KLM), Ambiguous compiler warnings
			 *
                tm.tm_wday = (++tm.tm_wday % 7);
			 */
				tm.tm_wday++; tm.tm_wday %= 7;
            }
            break;
  
  
        case 2:  /* Only minutes given, so apply current time & date - WG7J */
            time(&nowtime);
            memcpy((void *)&tm, (void *)localtime(&nowtime), sizeof(struct tm));

            i = atoi(argv[1]);
            if(i > 59)
				return (do_error (exp_date, exp_time, cp));
  
        /* if we're already at or past the minute, do it next hour ! */
            if(tm.tm_min >= i)
                tm.tm_hour++;
            tm.tm_min = (char)i;
  
        /* now adjust this for day boundaries, etc. */
            tm.tm_sec = 5;  /* n5knx: assure we're never early */

            time1 = mktime(&tm);
            break;
  
        case 8:  /* now+hhmm given */
            strncpy(cp,argv[1],4);
            cp[4]='\0';
            if(strcmp(cp,"now+") != 0)
				return (do_error (exp_date, exp_time, cp));
  
            cp[0]=argv[1][4];
            cp[1]=argv[1][5];
            cp[2]='\0';
  
            time1=(unsigned long)atoi(cp)*3600L;
  
            cp[0]=argv[1][6];
            cp[1]=argv[1][7];
            cp[2]='\0';
  
            time1+=(unsigned long)atoi(cp)*60L;
            time(&nowtime);
            time1+=(unsigned long)nowtime;
            break;
  
        default:
			return (do_error (exp_date, exp_time, cp));
  
    } /* switch */
  
    free(cp);
    free(exp_time);
    free(exp_date);
  
#define MAX_DELTA_TIME	MAXINT32 / 1000L
    if ((time1 - nowtime) > MAX_DELTA_TIME) {  /* nowtime is good enough */
        tprintf("Time too far in future.\n");
        return 1;
    }
    t=(struct timer *)mallocw(sizeof(struct timer));
  
    set_timer(t,(time1 - /* n5knx: could be stale! (unsigned long)nowtime*/ time(NULL)) * 1000L);
    t->state=TIMER_RUN;
    t->func=(void (*)__ARGS((void*)))atcmd;
    t->arg=(char *)mallocw(strlen(argv[2])+12); /*crh*/
    sprintf(t->arg,"%s|%d",argv[2],id);
  
    /* Add the new timer to the head of List Of Events */
    loe=(struct at_list *)mallocw(sizeof(struct at_list));
/*
 * if timer is recursive, set at_list->recur and tack
 *  the '+' character to the end of the timer argument
 */

   /*
    * 20May2021, Maiko (VE4KLM), this is a pointer now
    *
    loe->recur[0] = 0;
    */
    loe->recur = (char*)0;

    if(argv[2][strlen(argv[2])-1] == '+')
    {
        /*
	 * 20May2021, Maiko (VE4KLM)
	 * replace static member with allocated pointer
	 *
	 * strcpy(loe->recur,argv[1]);
	 */
	loe->recur = j2strdup (argv[1]);
        strcat(t->arg,"+");
    }
    loe->at_timer=t;
    loe->id=id++;
/*
 * start the timer
 */
    start_timer(t);
/*
 * an id of 0 is invalid
 */
    if(id==0) id=1;
    loe->next=Head_loe;
    Head_loe=loe;
  
    return 0;
}
  
struct proc *Aproc;
  
/* Process that actually handles 'at' execution */
void
atproc(int i,void *p1,void *p2)
{
    extern struct cmds DFAR Cmds[];
    char *command;
    struct at_list *loe, *p;
    int recur, id, safety = 0;
    char *pp;
    char *cmd=NULLCHAR;
  
    command =  (char *)p1;
  
    log(-1,"AT command: %s",command);
  
/*
 * check for recursion
 */
    if(command[strlen(command)-1] == '+')
        recur=1;
    else
        recur=0;
/*
 * locate id in command string
 */
    pp = strrchr(command,'|');
    *pp++ = 0;
    id = atoi(pp);
  
    /* Free up memory for expired at commands */
    p=Head_loe;
    loe=Head_loe;
    while(loe != NULLATLIST){
        if(loe->at_timer->state == TIMER_EXPIRE){
            if((int)loe->id != id)
            {
				if (safety++ > 10)
					log (-1, "possible AT loop ? list id %d id %d", (int)(loe->id), id);

				if (safety++ > 15)
				{
					log (-1, "breaking out AT loop");
					break;
				}

                continue; /* is this the proper entry? */
            }
			safety = 0;

            if(recur)
            {	
		/*
		 * 20May2021, Maiko (VE4KLM), replace static with alloced pointer
		 * I also noticed they didn't account for a string termination,
		 * and asking myself why the trailing space (leave it for now).
		 *
                char prefix[sizeof(loe->recur)+4];
		 *
		 */
		char *prefix = mallocw (strlen (loe->recur) + 5);
                sprintf(prefix, "at %s ", loe->recur);
		// log (-1, "prefix [%s]", prefix);
                cmd=requote(command, prefix, "");
                command[strlen(command)-1]=0;  /* kill the + */

		free (prefix);	/* make sure of this, we don't need it anymore */
            }
            free(loe->at_timer);    /* Free timer */
            if(loe == Head_loe){
                Head_loe=loe->next;
                p=loe->next;
		if (loe->recur)			/* 20May2021, Maiko */
			free (loe->recur);
                free(loe);
                loe=p;
                p=Head_loe;
            } else {
                p->next=loe->next;
		if (loe->recur)			/* 20May2021, Maiko */
			free (loe->recur);
                free(loe);
                loe=p->next;
            }
            break;  /* exit while loop */
        } else {    /* Not expired, go on */
            if(loe != Head_loe) p=p->next;
            loe=loe->next;
        }
    }
  
    cmdparse(Cmds,command,NULL);    /* Go with requested command */
  
    if(recur) {
        cmdparse(Cmds,cmd,NULL);
        free (cmd);
    }
  
    free(command);
  
}
  
struct proc *Aproc;
  
/* Function to be called on timer expiration to execute a command */
void
atcmd(command)
char *command;
{
    Aproc = newproc("AT handler",1024,atproc,0,(void *)command,NULL,0);
}

/* Quote and copy string s, to allocated storage, while prefixing any '"'
 * with a backslash.  This enables cmdparse() to rescan the resultant string
 * back into itself.  String s is not modified.  Don't forget to free the
 * return pointer.  N5KNX 1.10n.
 * [Ought to be in cmdparse.c but only needed here (so far).]
 */
char *
requote(char *s, char *prepend, char *append)
{
    register char *result, *p, *q;
    unsigned reslen = strlen(prepend)+strlen(append)+strlen(s)+3;  /* room for: prepend " s " append NUL */

    result = mallocw(reslen);
    strcpy(result,prepend);
    strcat(result,"\"");
    while(s) {
        p = strchr(s, '"');
        if (p) {
            q=mallocw(++reslen);  /* extend result by 1 char */
            strcpy(q,result);
            free(result);
            result = q;
            strncat(result, s, (int)(p-s));
            strcat(result, "\\\"");  /* \ " */
            p++;
        }
        else
            strcat(result, s);
        s=p;
    }
    strcat(result,"\"");
    strcat(result,append);
    return(result);
}

#endif /* ATCMD */
  
